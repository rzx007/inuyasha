<!-- 78274145-4573-411e-9007-cb1522312002 70305367-b7d4-4544-9234-92baccb0a917 -->
# 优化 PageRoot 拖拽体验

## 问题分析

当前 PageRoot 只有在组件之间才能精确拖拽，大片空白区域无法接收拖拽，用户体验不佳。

## 解决方案

### 方案选择

创建 `PageRootDropZone` 组件，专门用于 PageRoot 的拖拽容器：

1. **使用相对定位容器 + 绝对定位的背景 drop 层**

   - 容器使用 `position: relative`
   - 背景 drop 层使用 `position: absolute`，覆盖整个容器
   - 子组件（EditorComponentWrapper）在上层，z-index 更高
   - 背景层处理"拖到空白区域"的逻辑（添加到末尾）
   - 子组件继续处理精确的排序逻辑

2. **拖拽高亮反馈**

   - 背景层悬停时显示淡蓝色背景
   - 不影响子组件的排序指示器

### 实现步骤

#### 1. 创建 PageRootDropZone 组件

新建 `app/src/components/Editor/PageRootDropZone.vue`：

```vue
<script setup lang="ts">
import { useDrop } from 'vue3-dnd'
import { DndTypes, type DragItem } from '@/types/dnd'
import { useEditorStore } from '@/stores/editor'

interface Props {
  parentId: string
  styleObject?: Record<string, any>
}
const props = defineProps<Props>()
const editorStore = useEditorStore()

// 背景层拖拽逻辑 - 添加到末尾
const [collected, drop] = useDrop(() => ({
  accept: [DndTypes.COMPONENT, DndTypes.EXISTING_COMPONENT],
  drop: (item: DragItem, monitor) => {
    // 如果子组件已处理，不重复处理
    if (monitor.didDrop()) {
      return
    }
    
    // 添加到末尾
    if (item.type === DndTypes.COMPONENT) {
      const { meta, cloneFn } = item
      if (meta && cloneFn) {
        const newComponent = cloneFn(meta)
        if (newComponent) {
          editorStore.addComponent(newComponent, props.parentId)
        }
      }
    } else if (item.type === DndTypes.EXISTING_COMPONENT) {
      editorStore.moveComponent(item.id, props.parentId)
    }
    
    return { dropped: true }
  },
  collect: (monitor) => ({
    isOver: monitor.isOver({ shallow: true }),
    canDrop: monitor.canDrop(),
  }),
}))
</script>

<template>
  <div class="page-root-drop-zone relative min-h-full" :style="styleObject">
    <!-- 背景拖拽层（绝对定位，全覆盖） -->
    <div
      :ref="drop"
      class="absolute inset-0 pointer-events-auto"
      :class="{ 'bg-primary/5': collected.isOver && collected.canDrop }"
    />
    
    <!-- 子组件层（相对定位，z-index 更高） -->
    <div class="relative z-10 pointer-events-auto">
      <slot />
    </div>
  </div>
</template>
```

#### 2. 修改 DynamicRenderer

在 `DynamicRenderer.vue` 中：

- 导入 `PageRootDropZone`
- PageRoot 渲染时使用 `PageRootDropZone` 包裹
- 移除条件渲染的 `SlotDropWrapper`（PageRootDropZone 已处理所有情况）
```vue
<!-- PageRoot 组件 -->
<PageRootDropZone
  v-if="schema.type === ComponentType.PageRoot"
  :parent-id="schema.id"
  :style-object="styleObject"
>
  <EditorComponentWrapper 
    v-for="(child, index) in children" 
    :key="child.id" 
    :schema="child" 
    :index="index"
    :parent-id="schema.id"
  />
  
  <!-- 空状态提示（不是拖拽目标，只是视觉提示） -->
  <div v-if="children.length === 0" class="empty-hint">
    将组件拖到此处
  </div>
</PageRootDropZone>
```


#### 3. 更新 PreviewRenderer（可选）

PreviewRenderer 不需要拖拽功能，保持简单的渲染即可。

## 预期效果

- ✅ PageRoot 整个区域都可以接收拖拽
- ✅ 拖到空白区域 = 添加到末尾
- ✅ 拖到组件之间 = 精确排序（EditorComponentWrapper 处理）
- ✅ 拖拽高亮反馈清晰
- ✅ DOM 层级不受影响（子组件仍是直接子级）